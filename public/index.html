<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Public Chat</title>
  <style>
    /* Все предыдущие стили остаются */
    
    /* Новые стили для анимаций и индикатора набора */
    .message {
      opacity: 0;
      transform: translateY(10px);
      animation: messageAppear 0.3s ease-out forwards;
    }
    
    @keyframes messageAppear {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .typing-indicator {
      padding: 8px 16px;
      color: #86a0bb;
      font-size: 14px;
      font-style: italic;
      display: flex;
      align-items: center;
      gap: 8px;
      opacity: 0;
      transform: translateY(-10px);
      transition: all 0.3s ease;
    }
    
    .typing-indicator.show {
      opacity: 1;
      transform: translateY(0);
    }
    
    .typing-dots {
      display: flex;
      gap: 3px;
    }
    
    .typing-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #3b82f6;
      animation: typingDot 1.4s ease-in-out infinite both;
    }
    
    .typing-dot:nth-child(1) { animation-delay: -0.32s; }
    .typing-dot:nth-child(2) { animation-delay: -0.16s; }
    
    @keyframes typingDot {
      0%, 80%, 100% {
        transform: scale(0.8);
        opacity: 0.5;
      }
      40% {
        transform: scale(1);
        opacity: 1;
      }
    }
    
    .message-sending {
      opacity: 0.6;
    }
    
    .message-sent {
      animation: messageHighlight 1s ease;
    }
    
    @keyframes messageHighlight {
      0% {
        background: rgba(59, 130, 246, 0.1);
      }
      100% {
        background: transparent;
      }
    }
    
    .avatar-typing {
      position: relative;
    }
    
    .avatar-typing::after {
      content: '';
      position: absolute;
      bottom: -2px;
      right: -2px;
      width: 12px;
      height: 12px;
      background: #3b82f6;
      border-radius: 50%;
      border: 2px solid #0b1220;
      animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
      0% {
        transform: scale(0.8);
        opacity: 1;
      }
      50% {
        transform: scale(1.1);
        opacity: 0.7;
      }
      100% {
        transform: scale(0.8);
        opacity: 1;
      }
    }
  </style>
</head>
<body>
  <!-- Все HTML разметка остается без изменений -->

  <script>
    // Добавляем новые функции для реального времени
    
    // Глобальные переменные
    let currentChannel = 'general';
    let channels = {};
    let currentAvatarFile = null;
    let isTyping = false;
    let typingTimeout = null;
    let longPolling = null;
    
    // Функция для начала long polling
    function startLongPolling() {
      if (longPolling) return;
      
      const poll = async () => {
        try {
          const response = await apiCall(`/channels/${currentChannel}/updates?lastUpdate=${Date.now()}`);
          
          if (response.type === 'new_message') {
            // Добавляем новое сообщение с анимацией
            addNewMessage(response.message);
          } else if (response.type === 'typing_update') {
            // Обновляем индикатор набора текста
            updateTypingIndicator(response.users);
          } else if (response.type === 'message_deleted') {
            // Удаляем сообщение
            removeMessage(response.messageId);
          } else if (response.type === 'message_updated') {
            // Обновляем сообщение
            updateMessage(response.message);
          }
          
          // Сразу начинаем следующий запрос
          poll();
        } catch (error) {
          console.error('Long polling error:', error);
          // Перезапускаем через 2 секунды при ошибке
          setTimeout(poll, 2000);
        }
      };
      
      poll();
    }
    
    // Функция для отправки статуса набора текста
    function sendTypingStatus(isTyping) {
      if (isTyping === isTyping) return;
      
      isTyping = isTyping;
      apiCall(`/channels/${currentChannel}/typing`, {
        method: 'POST',
        body: JSON.stringify({ isTyping })
      }).catch(console.error);
    }
    
    // Функция для добавления нового сообщения с анимацией
    function addNewMessage(message) {
      const messagesEl = document.getElementById('messages');
      const currentUser = localStorage.getItem('chat_username');
      
      // Проверяем, нет ли уже такого сообщения
      const existingMessage = messagesEl.querySelector(`[data-message-id="${message.id}"]`);
      if (existingMessage) return;
      
      const el = createMessageElement(message, currentUser);
      messagesEl.appendChild(el);
      
      // Прокручиваем к новому сообщению
      messagesEl.scrollTop = messagesEl.scrollHeight;
      
      // Анимация появления
      setTimeout(() => {
        el.classList.add('message-sent');
      }, 100);
    }
    
    // Функция для создания элемента сообщения
    function createMessageElement(msg, currentUser) {
      const el = document.createElement('div');
      el.className = 'message';
      el.dataset.messageId = msg.id;
      
      const avatar = document.createElement('div');
      avatar.className = 'avatar';
      if (msg.avatar) {
        const img = document.createElement('img');
        img.src = msg.avatar;
        img.alt = msg.username;
        avatar.appendChild(img);
      } else {
        avatar.textContent = initials(msg.username);
      }
      
      const body = document.createElement('div');
      body.className = 'message-body' + (msg.username === currentUser ? ' own-message' : '');
      
      const header = document.createElement('div');
      header.className = 'message-header';
      
      const nickEl = document.createElement('div');
      nickEl.className = 'nickname';
      nickEl.textContent = msg.username;
      
      const timeEl = document.createElement('div');
      timeEl.className = 'time';
      timeEl.textContent = formatTime(msg.timestamp);
      if (msg.edited) {
        const editedBadge = document.createElement('span');
        editedBadge.className = 'edited-badge';
        editedBadge.textContent = '(ред.)';
        timeEl.appendChild(editedBadge);
      }
      
      header.appendChild(nickEl);
      header.appendChild(timeEl);
      
      // Add edit and delete buttons for own messages
      if (msg.username === currentUser || isAdmin()) {
        const editBtn = document.createElement('button');
        editBtn.className = 'edit-btn';
        editBtn.textContent = '✎';
        editBtn.title = 'Редактировать сообщение';
        editBtn.addEventListener('click', async () => {
          await handleEditMessage(msg);
        });
        header.appendChild(editBtn);
        
        const delBtn = document.createElement('button');
        delBtn.className = 'delete-btn';
        delBtn.textContent = '×';
        delBtn.title = 'Удалить сообщение';
        delBtn.addEventListener('click', async () => {
          if (confirm('Удалить сообщение?')) {
            try {
              await deleteMessage(currentChannel, msg.id);
            } catch (error) {
              alert('Ошибка при удалении: ' + error.message);
            }
          }
        });
        header.appendChild(delBtn);
      }
      
      const text = document.createElement('div');
      text.className = 'message-text';
      text.innerHTML = linkify(escapeHtml(msg.text));
      
      body.appendChild(header);
      body.appendChild(text);
      el.appendChild(avatar);
      el.appendChild(body);
      
      return el;
    }
    
    // Функция для обновления индикатора набора текста
    function updateTypingIndicator(typingUsers) {
      const messagesEl = document.getElementById('messages');
      let indicator = messagesEl.querySelector('.typing-indicator');
      
      // Удаляем старый индикатор если нет набирающих
      if (typingUsers.length === 0) {
        if (indicator) {
          indicator.classList.remove('show');
          setTimeout(() => indicator.remove(), 300);
        }
        return;
      }
      
      // Создаем новый индикатор если его нет
      if (!indicator) {
        indicator = document.createElement('div');
        indicator.className = 'typing-indicator';
        messagesEl.appendChild(indicator);
        
        // Даем время для применения стилей перед анимацией
        setTimeout(() => indicator.classList.add('show'), 10);
      }
      
      // Обновляем текст
      const usersText = typingUsers.length === 1 
        ? `${typingUsers[0]} печатает`
        : `${typingUsers.slice(0, -1).join(', ')} и ${typingUsers[typingUsers.length - 1]} печатают`;
      
      indicator.innerHTML = `
        <div class="typing-dots">
          <div class="typing-dot"></div>
          <div class="typing-dot"></div>
          <div class="typing-dot"></div>
        </div>
        <span>${usersText}</span>
      `;
      
      // Обновляем аватары в списке каналов
      updateTypingAvatars(typingUsers);
    }
    
    // Функция для обновления аватаров с индикатором набора
    function updateTypingAvatars(typingUsers) {
      const channelsList = document.getElementById('channelsList');
      const channels = channelsList.querySelectorAll('.channel');
      
      channels.forEach(channel => {
        const channelKey = channel.dataset.key;
        if (channelKey === currentChannel) {
          const avatar = channel.querySelector('.avatar');
          if (avatar) {
            if (typingUsers.length > 0) {
              avatar.classList.add('avatar-typing');
            } else {
              avatar.classList.remove('avatar-typing');
            }
          }
        }
      });
    }
    
    // Функция для удаления сообщения
    function removeMessage(messageId) {
      const messagesEl = document.getElementById('messages');
      const messageEl = messagesEl.querySelector(`[data-message-id="${messageId}"]`);
      if (messageEl) {
        messageEl.style.opacity = '0';
        messageEl.style.transform = 'translateX(-20px)';
        setTimeout(() => messageEl.remove(), 300);
      }
    }
    
    // Функция для обновления сообщения
    function updateMessage(updatedMessage) {
      const messagesEl = document.getElementById('messages');
      const messageEl = messagesEl.querySelector(`[data-message-id="${updatedMessage.id}"]`);
      if (messageEl) {
        const textEl = messageEl.querySelector('.message-text');
        const timeEl = messageEl.querySelector('.time');
        
        if (textEl) {
          textEl.innerHTML = linkify(escapeHtml(updatedMessage.text));
        }
        
        // Добавляем отметку о редактировании
        if (updatedMessage.edited && !timeEl.querySelector('.edited-badge')) {
          const editedBadge = document.createElement('span');
          editedBadge.className = 'edited-badge';
          editedBadge.textContent = '(ред.)';
          timeEl.appendChild(editedBadge);
        }
        
        // Анимация обновления
        messageEl.classList.add('message-sent');
      }
    }
    
    // Обновляем функцию отправки сообщения для мгновенного отображения
    async function sendMessage(channel, text) {
      const messageInput = document.getElementById('messageInput');
      const currentUser = localStorage.getItem('chat_username');
      
      // Создаем временное сообщение
      const tempMessage = {
        id: 'temp-' + Date.now(),
        text: text,
        username: currentUser,
        avatar: localStorage.getItem('chat_avatar'),
        timestamp: new Date().toISOString(),
        temp: true
      };
      
      // Добавляем временное сообщение
      addNewMessage(tempMessage);
      
      try {
        const result = await apiCall(`/channels/${channel}/messages`, {
          method: 'POST',
          body: JSON.stringify({ text })
        });
        
        // Заменяем временное сообщение на настоящее
        const messagesEl = document.getElementById('messages');
        const tempEl = messagesEl.querySelector(`[data-message-id="${tempMessage.id}"]`);
        if (tempEl) {
          tempEl.remove();
        }
        
        // Настоящее сообщение добавится через long polling
      } catch (error) {
        // Удаляем временное сообщение при ошибке
        const messagesEl = document.getElementById('messages');
        const tempEl = messagesEl.querySelector(`[data-message-id="${tempMessage.id}"]`);
        if (tempEl) {
          tempEl.remove();
        }
        throw error;
      }
    }
    
    // Обновляем функцию переключения канала
    async function switchChannel(channel) {
      currentChannel = channel;
      const channelData = channels[channel];
      
      document.getElementById('currentChannel').textContent = (channelData.isPrivate ? '🔒' : '#') + channel;
      
      const description = channelData.title + ' — ' + (channelData.isPrivate ? 'приватный канал' : 'публичный канал');
      document.getElementById('channelDescription').textContent = description;
      
      // Show/hide add user button for private channels
      const addUserBtn = document.getElementById('addUserBtn');
      if (channelData.isPrivate) {
        addUserBtn.classList.remove('hidden');
      } else {
        addUserBtn.classList.add('hidden');
      }
      
      renderChannels(channels, currentChannel);
      await refreshMessages();
      
      // Перезапускаем long polling для нового канала
      startLongPolling();
    }
    
    // Обновляем обработчик ввода сообщения для индикатора набора
    const messageInput = document.getElementById('messageInput');
    messageInput.addEventListener('input', () => {
      autoResizeTextarea(messageInput);
      
      // Управление индикатором набора текста
      if (!isTyping) {
        sendTypingStatus(true);
      }
      
      // Сбрасываем таймер
      clearTimeout(typingTimeout);
      typingTimeout = setTimeout(() => {
        sendTypingStatus(false);
      }, 1000);
    });
    
    // Также сбрасываем индикатор при отправке сообщения
    const originalSendHandler = document.getElementById('sendBtn').onclick;
    document.getElementById('sendBtn').onclick = async function() {
      sendTypingStatus(false);
      clearTimeout(typingTimeout);
      await originalSendHandler();
    };
    
    // Запускаем long polling при загрузке
    document.addEventListener('DOMContentLoaded', async () => {
      // ... существующий код инициализации ...
      
      // После успешной загрузки запускаем long polling
      setTimeout(startLongPolling, 1000);
    });
    
    // Все остальные функции остаются без изменений
  </script>
</body>
</html>
